## Высокий приоритет
1. Дублирование кода в конструкторах PaintPanel - код дублируется во всех 3х конструкторах следует избегать дублирование кода, нужно вынести код в отдельный метод или использовать например конструкцию this(context, null) в первом конструкторе для вызова второго а во втором использовать соответствующую запись для вызова третьего, и весь код поместить в 3й конструктор тем самым избавиться от дублирования.

2. PaintPanel: Инфлейт лэйаута делается в зависимости от ориентации экрана, это делать не нужно т.к. это это сделает андроид фреймворк нужно только положить соответсвующие лэйауты в нужные папки т.е. для ландшафтной ориентации лэйаут должен лежать в папке layout-land

3. Методы setOnClickListener для кнопок undoBtn, redoBtn, clearBtn, fillBtn - выглядят однотипно, для уменьшения метода init лучшим решением было бы использование одного листнера для всех 4х кнопок

4. Листнеры для сикбаров - redSeekBar, greenSeekbar, blueSeekBar, alphaSeekBar - одинаковые, незачем создавать 3 одинаковых объекта можно и нужно использовать один

5. LightpaintView - private boolean mIsDown = false; это поле выглядит лишним, без него будет работать также

## Средний приоритет
1. PaintPanel#setTextAndValues - этот метод делает слишком много - вычисляет цвет, устанавливает цвет, меняет бэкграунд стоит разделить его на как минимум на 3 метода - установка текста, установка цвета и вычисление цвета.

2. PaintPanel#setTextAndValues
в методе вычисляется цвет - mColor = Color.argb(a,r,g,b); а далее вместо того что бы использовать этот текст для установки background используется метод - Color.parseColor(getTextFromRGB(r, g, b, mAlpha)) вместо этого можно сделать так frameLayout.setBackgroundColor(mColor);

3. Метод getTextFromRGB - можно упростить до 1 троки - String.format("#%02x%02x%02x%02x", a, r, g, b);

4. LightPaintView 
Вьюшка содержит 2 списка mPaths, mPaints в которых содержатся Path и Paint для рисования, доступ осуществляется по индексу, для рисовалки лучше использовать паттерн - Команда т.е. вместо 2х списков можно было использовать очередь и в нее складывать объекты: Линия, Прямоугольник, Овал и т.д. которые в содержали например Path и Paint (или только Paint) и содержали бы единственный метод void draw(Canvas canvas) - для отрисовки себя. Таким образом можно без проблем добавлять разные объекты для рисования (например треугольник) при этом легко вьюшка для рисования будет только вызывать метод draw() для отрисовки объекта и ей будет не важно какой именно это объект.

5. PaintPanel#eraser - этот метод просто рисует поверх белым цветом по идее он должен именно стирать все слои под ним, для этого нужно использовать метод - paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));

## Низкий приоритет
1. Сохранение состояния активити
Сохранение состояния рисовалки реализовано через синглтон что не гарантирует сохранение этого состояния, вместо синглтона нужно использовать механизм который предлагает андроид фреймворк - android.app.Activity#onSaveInstanceState(android.os.Bundle)
Такой подход позволит сохранить состояние между запусками даже если андроид завершит процесс приложения (например при нехватки памяти)



